[
  {
    "A_name" : "Reactive",
    "B_kind" : "extension",
    "C_accessLevel" : "internal",
    "D_attributes" : [

    ],
    "E_adoptedClassProtocols" : [

    ],
    "F_location" : "UITextView+Rx.swift - Line: 14, Column: 1",
    "G_members" : [
      {
        "A_name" : "text",
        "B_kind" : "variable",
        "C_accessLevel" : "public",
        "D_attributes" : [

        ],
        "F_location" : "UITextView+Rx.swift - Line: 16, Column: 5",
        "H_initialValue" : ""
      },
      {
        "A_name" : "value",
        "B_kind" : "variable",
        "C_accessLevel" : "public",
        "D_attributes" : [

        ],
        "F_location" : "UITextView+Rx.swift - Line: 21, Column: 5",
        "H_initialValue" : ""
      },
      {
        "A_name" : "attributedText",
        "B_kind" : "variable",
        "C_accessLevel" : "public",
        "D_attributes" : [

        ],
        "F_location" : "UITextView+Rx.swift - Line: 57, Column: 5",
        "H_initialValue" : ""
      },
      {
        "A_name" : "didBeginEditing",
        "B_kind" : "variable",
        "C_accessLevel" : "public",
        "D_attributes" : [

        ],
        "F_location" : "UITextView+Rx.swift - Line: 92, Column: 5",
        "H_initialValue" : ""
      },
      {
        "A_name" : "didEndEditing",
        "B_kind" : "variable",
        "C_accessLevel" : "public",
        "D_attributes" : [

        ],
        "F_location" : "UITextView+Rx.swift - Line: 100, Column: 5",
        "H_initialValue" : ""
      },
      {
        "A_name" : "didChange",
        "B_kind" : "variable",
        "C_accessLevel" : "public",
        "D_attributes" : [

        ],
        "F_location" : "UITextView+Rx.swift - Line: 108, Column: 5",
        "H_initialValue" : ""
      },
      {
        "A_name" : "didChangeSelection",
        "B_kind" : "variable",
        "C_accessLevel" : "public",
        "D_attributes" : [

        ],
        "F_location" : "UITextView+Rx.swift - Line: 116, Column: 5",
        "H_initialValue" : ""
      }
    ]
  },
  {
    "A_name" : "text",
    "B_kind" : "variable",
    "C_accessLevel" : "public",
    "D_attributes" : [

    ],
    "F_location" : "UITextView+Rx.swift - Line: 16, Column: 5",
    "H_initialValue" : ""
  },
  {
    "A_name" : "value",
    "B_kind" : "variable",
    "C_accessLevel" : "public",
    "D_attributes" : [

    ],
    "F_location" : "UITextView+Rx.swift - Line: 21, Column: 5",
    "H_initialValue" : ""
  },
  {
    "A_name" : "source",
    "B_kind" : "variable",
    "C_accessLevel" : "internal",
    "D_attributes" : [

    ],
    "F_location" : "UITextView+Rx.swift - Line: 22, Column: 9",
    "H_initialValue" : "Observable.deferred { [weak textView = self.base] in\n            let text = textView?.text\n            \n            let textChanged = textView?.textStorage\n                \/\/ This project uses text storage notifications because\n                \/\/ that's the only way to catch autocorrect changes\n                \/\/ in all cases. Other suggestions are welcome.\n                .rx.didProcessEditingRangeChangeInLength\n                \/\/ This observe on is here because text storage\n                \/\/ will emit event while process is not completely done,\n                \/\/ so rebinding a value will cause an exception to be thrown.\n                .observe(on:MainScheduler.asyncInstance)\n                .map { _ in\n                    return textView?.textStorage.string\n                }\n                ?? Observable.empty()\n            \n            return textChanged\n                .startWith(text)\n        }"
  },
  {
    "A_name" : "text",
    "B_kind" : "variable",
    "C_accessLevel" : "internal",
    "D_attributes" : [

    ],
    "F_location" : "UITextView+Rx.swift - Line: 23, Column: 13",
    "H_initialValue" : "textView?.text"
  },
  {
    "A_name" : "textChanged",
    "B_kind" : "variable",
    "C_accessLevel" : "internal",
    "D_attributes" : [

    ],
    "F_location" : "UITextView+Rx.swift - Line: 25, Column: 13",
    "H_initialValue" : "textView?.textStorage\n                \/\/ This project uses text storage notifications because\n                \/\/ that's the only way to catch autocorrect changes\n                \/\/ in all cases. Other suggestions are welcome.\n                .rx.didProcessEditingRangeChangeInLength\n                \/\/ This observe on is here because text storage\n                \/\/ will emit event while process is not completely done,\n                \/\/ so rebinding a value will cause an exception to be thrown.\n                .observe(on:MainScheduler.asyncInstance)\n                .map { _ in\n                    return textView?.textStorage.string\n                }\n                ?? Observable.empty()"
  },
  {
    "A_name" : "bindingObserver",
    "B_kind" : "variable",
    "C_accessLevel" : "internal",
    "D_attributes" : [

    ],
    "F_location" : "UITextView+Rx.swift - Line: 43, Column: 9",
    "H_initialValue" : "Binder(self.base) { (textView, text: String?) in\n            \/\/ This check is important because setting text value always clears control state\n            \/\/ including marked text selection which is important for proper input\n            \/\/ when IME input method is used.\n            if textView.text != text {\n                textView.text = text\n            }\n        }"
  },
  {
    "A_name" : "attributedText",
    "B_kind" : "variable",
    "C_accessLevel" : "public",
    "D_attributes" : [

    ],
    "F_location" : "UITextView+Rx.swift - Line: 57, Column: 5",
    "H_initialValue" : ""
  },
  {
    "A_name" : "source",
    "B_kind" : "variable",
    "C_accessLevel" : "internal",
    "D_attributes" : [

    ],
    "F_location" : "UITextView+Rx.swift - Line: 58, Column: 9",
    "H_initialValue" : "Observable.deferred { [weak textView = self.base] in\n            let attributedText = textView?.attributedText\n            \n            let textChanged: Observable<NSAttributedString?> = textView?.textStorage\n                \/\/ This project uses text storage notifications because\n                \/\/ that's the only way to catch autocorrect changes\n                \/\/ in all cases. Other suggestions are welcome.\n                .rx.didProcessEditingRangeChangeInLength\n                \/\/ This observe on is here because attributedText storage\n                \/\/ will emit event while process is not completely done,\n                \/\/ so rebinding a value will cause an exception to be thrown.\n                .observe(on:MainScheduler.asyncInstance)\n                .map { _ in\n                    return textView?.attributedText\n                }\n                ?? Observable.empty()\n            \n            return textChanged\n                .startWith(attributedText)\n        }"
  },
  {
    "A_name" : "attributedText",
    "B_kind" : "variable",
    "C_accessLevel" : "internal",
    "D_attributes" : [

    ],
    "F_location" : "UITextView+Rx.swift - Line: 59, Column: 13",
    "H_initialValue" : "textView?.attributedText"
  },
  {
    "A_name" : "textChanged",
    "B_kind" : "variable",
    "C_accessLevel" : "internal",
    "D_attributes" : [

    ],
    "F_location" : "UITextView+Rx.swift - Line: 61, Column: 13",
    "H_initialValue" : "textView?.textStorage\n                \/\/ This project uses text storage notifications because\n                \/\/ that's the only way to catch autocorrect changes\n                \/\/ in all cases. Other suggestions are welcome.\n                .rx.didProcessEditingRangeChangeInLength\n                \/\/ This observe on is here because attributedText storage\n                \/\/ will emit event while process is not completely done,\n                \/\/ so rebinding a value will cause an exception to be thrown.\n                .observe(on:MainScheduler.asyncInstance)\n                .map { _ in\n                    return textView?.attributedText\n                }\n                ?? Observable.empty()"
  },
  {
    "A_name" : "bindingObserver",
    "B_kind" : "variable",
    "C_accessLevel" : "internal",
    "D_attributes" : [

    ],
    "F_location" : "UITextView+Rx.swift - Line: 79, Column: 9",
    "H_initialValue" : "Binder(self.base) { (textView, attributedText: NSAttributedString?) in\n            \/\/ This check is important because setting text value always clears control state\n            \/\/ including marked text selection which is important for proper input\n            \/\/ when IME input method is used.\n            if textView.attributedText != attributedText {\n                textView.attributedText = attributedText\n            }\n        }"
  },
  {
    "A_name" : "didBeginEditing",
    "B_kind" : "variable",
    "C_accessLevel" : "public",
    "D_attributes" : [

    ],
    "F_location" : "UITextView+Rx.swift - Line: 92, Column: 5",
    "H_initialValue" : ""
  },
  {
    "A_name" : "didEndEditing",
    "B_kind" : "variable",
    "C_accessLevel" : "public",
    "D_attributes" : [

    ],
    "F_location" : "UITextView+Rx.swift - Line: 100, Column: 5",
    "H_initialValue" : ""
  },
  {
    "A_name" : "didChange",
    "B_kind" : "variable",
    "C_accessLevel" : "public",
    "D_attributes" : [

    ],
    "F_location" : "UITextView+Rx.swift - Line: 108, Column: 5",
    "H_initialValue" : ""
  },
  {
    "A_name" : "didChangeSelection",
    "B_kind" : "variable",
    "C_accessLevel" : "public",
    "D_attributes" : [

    ],
    "F_location" : "UITextView+Rx.swift - Line: 116, Column: 5",
    "H_initialValue" : ""
  }
]